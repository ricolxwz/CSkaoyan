\chapter{计算机系统概述}
\section{操作系统的基本概念}
\textbf{多任务处理和多重处理之间的区别:} 多任务处理指的是操作系统允许多个进程都处在运行的状态(这里指的是广义的运行), 多重处理基于多核\verb|CPU|, 指的是同一时刻能有多个程序在\verb|CPU|上执行.\par \vspace{.5em}
\textbf{数据库系统}是应用软件, \textbf{数据库管理系统}是系统软件.
\section{操作系统发展历程}
实时操作系统\textbf{不存在交互功能}, 而分时操作系统是\textbf{一定具有人际交互功能的}.\par \vspace{.5em}
多任务操作系统具有\textbf{并发和并行}的特点, 这里的并行指的是\textbf{处理机和设备之间并行}.\par \vspace{.5em}
\textbf{多道程序操作系统相比于单道程序操作系统的优点:} \verb|CPU|利用率提升, 吞吐量提升, \textbf{设备的利用率升高(引入了中断处理)}.
\section{操作系统运行环境}
\textbf{通道技术}是一种特殊的处理器技术, 是独立于\verb|CPU|的, 可以并行.\par \vspace{.5em}
\textbf{中断处理程序一定是在内核态执行的}. \par \vspace{.5em}
\textbf{中断处理程序}一定是\textbf{\texttt{os程序}}, \textbf{中断程序}有可能是\textbf{\texttt{os程序}}, 也有可能是\textbf{用户程序}.\par \vspace{.5em}
\textbf{用户态到核心态的转换是由硬件实现的}. \par \vspace{.5em}
在核心态下才能执行的指令举例: \textbf{关中断, 清内存, 置时钟, 修改用户管理权限, 修改段表或者页表, 分配系统资源}.\par \vspace{.5em}
中断处理过程中最重要的两个寄存器是\textbf{\texttt{PC}和\texttt{PSW}(程序状态字寄存器)}, 这两个寄存器由中断隐指令自动保存, 另外寄存器的指令由操作系统保存.
\section{操作系统结构}
微内核相比于宏内核的优势: \textbf{可移植性, 可扩展性, 可靠性}. 劣势: 执行效率低.
\chapter{进程与线程}
\section{进程与线程}
进程是一个具有独立功能的程序关于某个数据集合的一次运行活动. \par \vspace{.5em}
线程包含\verb|CPU|现场, 可以独立执行程序. 而且同一个进程下的各个进程之间切换\verb|CPU|线程信息相比于进程切换来说需要保存的更少. \par \vspace{.5em}
同一个进程内的线程是\textbf{没有自己的地址空间}的. 他们共享进程的地址空间, 只有一丁点自己的资源. 基于数据段进行通信. \par \vspace{.5em}
\textbf{进程的封闭性:} 封闭性的意思是程序的执行结果\textbf{只取决于进程本身}. 程序失去并发性的意思就是并发进程共享变量, 其执行结果与速度有关.\par \vspace{.5em}
\verb|C|语言程序中的内容和相关的数据结构在进程结构中的哪一段: 全局赋值变量和常量放在正文段, 函数调用的实参传递值和未赋值的局部变量放在栈段, 要求\verb|malloc()|动态分配的区域放在堆段. 进程的优先级放在\verb|PCB|中. \par \vspace{.5em}
降低进程优先级和升高进程优先级的时机: 应当提高优先级的事件有进程长期处于就绪队列, 进程刚完成\verb|IO|操作进入就绪队列; 应当降低优先级的事件有进程的时间片刚用完. 不用调整优先级的事件有进程从就绪态转为运行态.\par \vspace{.5em}
\textbf{线程也有不能共享的东西:} 栈指针, 进程中的线程共享进程的全部资源,但是进程中的栈指针对其他的线程是透明的, 不能和其他线程共享.\par \vspace{.5em}
\section{处理机调度}
\textbf{作业和进程的区别}: 作业是用户提交的, 以用户的任务为单位; 进程是系统自动生成的, 以操作系统控制为单位.\par \vspace{.5em}
\textbf{进程在临界区的时候处理机是可以进行进程调度的}, 只要不破坏临界资源的使用规则.(非常坑的一道题)\par \vspace{.5em}
在考虑优先级调度算法的时候, 一般来说, \verb|IO|型作业的优先权高于作业的优先权, 这是由于\verb|IO|操作需要及时的完成, 他们有很长时间保存所要输入输出的数据, 所以, \verb|IO|繁忙型作业应该有更高的优先级.
\section{同步和互斥}
\textbf{可重入代码}: 允许多个进程同时访问的代码.(经常考)\par \vspace{.5em}
\textbf{临界区是}指并发进程访问共享变量段的\textbf{代码}.\par \vspace{.5em}
一个正在访问临界资源的进程由于申请等待\verb|IO|操作而被中断时, \textbf{是允许其他进程抢占处理器的, 但是不得进入该临界区}.\par \vspace{.5em}
临界区是指并发进程访问共享变量段的\textbf{代码程序}.\par \vspace{.5em}
磁盘存储介质不属于临界资源, \textbf{公用队列属于临界资源}.\par \vspace{.5em}
实现进程同步的信号量的值是\textbf{由用户确定的}, 而互斥信号量的初始值一般是\verb|1|.\par \vspace{.5em}
\verb|PV|操作是一种低级的进程通信原语, 不是系统调用.\par \vspace{.5em}
\section{死锁}
解除死锁的方法: \textbf{资源剥夺法}, 挂起某些死锁进程, 并抢占他们的资源, 将这些资源分配给其他的死锁进程. \textbf{撤销进程法}, 强制撤销\textbf{部分}甚至\textbf{全部}的死锁进程并剥夺这些进程的资源.\par \vspace{.5em}
根据资源有向图, 只要有孤立进程且能够消除循环等待链, 就能解除死锁的状态.\par  {\kaishu(\textbf{例题1} 某系统中有3个并发进程都需要4个同类的资源, 则该系统必然不会发生死锁的最少资源是?, 最极端的情况是2个进程刚好拥有了3个资源, 而另外的1个进程刚好拥有4个资源, 那么后者如果释放资源, 就能唤醒前两个进程.\par \textbf{例题2} 又如: 某系统中共有11台磁带机, X个进程共享此设备, 每个进程最多请求使用3台, 则系统必然不会死锁的最大X值是?, 根据前面的算法, 我们认为有X-1个进程拥有2个资源, 另外的一个进程拥有3个资源, 后者释放后就有可能唤醒前面的X-1个进程, 故可以列出方程: 3+2*(X-1)=11, 得到X=5)}\par \vspace{.5em}
死锁的四个必要条件中, 无法破坏的是\textbf{互斥使用资源}, 因为有些进程是不能被同时访问的.\par \vspace{.5em}
死锁状态和不安全状态的关系: 不安全状态\textbf{包含}死锁状态. 死锁状态一定是安全状态.


